<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­åœ‹è±¡æ£‹ (å¤§ç›¤ & å°ç›¤) - ç·šä¸Šå°æˆ°ç‰ˆ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes ping-slow {
            0% { transform: scale(1); opacity: 0.8; }
            75%, 100% { transform: scale(2); opacity: 0; }
        }
        .animate-ping-slow {
            animation: ping-slow 0.8s cubic-bezier(0, 0, 0.2, 1) forwards;
        }
        @keyframes flash-button {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(234, 88, 12, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px 5px rgba(234, 88, 12, 0.5); }
        }
        .animate-flash-button {
            animation: flash-button 1.5s infinite ease-in-out;
        }
        /* æ»¾å‹•æ¢ç¾åŒ– */
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background-color: rgba(156, 163, 175, 0.5); border-radius: 20px; }
        
        body {
            font-family: "Noto Serif TC", serif;
            overscroll-behavior: none;
        }
    </style>
</head>
<body class="bg-stone-900 text-stone-100">
    <div id="root"></div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, updateDoc, addDoc, arrayUnion, serverTimestamp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // ==============================================================================
        // ã€æœ¬æ©ŸåŸ·è¡Œè¨­å®šå€ã€‘
        // è«‹åœ¨æ­¤å¡«å…¥æ‚¨çš„ Firebase Config
        // ==============================================================================
        
        const LOCAL_FIREBASE_CONFIG ={
  apiKey: "AIzaSyAmYRuvHms3e0fbUqZW8ReiBIYBCZzgWTY",
  authDomain: "chinesechess-826cb.firebaseapp.com",
  projectId: "chinesechess-826cb",
  storageBucket: "chinesechess-826cb.firebasestorage.app",
  messagingSenderId: "595839849276",
  appId: "1:595839849276:web:640e25159cd91ef4f50439",
  measurementId: "G-TWRQ4R1V8Y"
}; 

        // ç¯„ä¾‹ (è«‹å°‡ä¸Šæ–¹ null æ›¿æ›ç‚ºæ‚¨çš„è¨­å®šç‰©ä»¶):
        /*
        const LOCAL_FIREBASE_CONFIG = {
          apiKey: "AIzaSyDxxxxxxxxxxxxxxxxxxxxxxxx",
          authDomain: "your-project.firebaseapp.com",
          projectId: "your-project-id",
          storageBucket: "your-project.firebasestorage.app",
          messagingSenderId: "1234567890",
          appId: "1:1234567890:web:xxxxxxxxxxxx"
        };
        */
        // ==============================================================================

        let app, auth, db;
        let isFirebaseConfigured = false;

        try {
            let config = null;
            if (LOCAL_FIREBASE_CONFIG) {
                config = LOCAL_FIREBASE_CONFIG;
                console.log("æ­£åœ¨ä½¿ç”¨æœ¬æ©Ÿ Firebase è¨­å®š...");
            } else if (window.__firebase_config) {
                config = JSON.parse(window.__firebase_config);
            }

            if (config && config.apiKey) {
                app = initializeApp(config);
                auth = getAuth(app);
                db = getFirestore(app);
                isFirebaseConfigured = true;
            }
        } catch (e) {
            console.warn("Firebase åˆå§‹åŒ–å¤±æ•—:", e);
        }

        const appId = window.__app_id || 'default-app-id';

        window.db = db || null;
        window.auth = auth || null;
        window.appId = appId;
        window.isFirebaseConfigured = isFirebaseConfigured;
        
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.onSnapshot = onSnapshot;
        window.updateDoc = updateDoc;
        window.addDoc = addDoc;
        window.arrayUnion = arrayUnion;
        window.serverTimestamp = serverTimestamp;
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Firebase Helper Functions ---
        const useFirebaseUser = () => {
            const [user, setUser] = useState(null);
            useEffect(() => {
                if (!window.isFirebaseConfigured || !window.auth) return;
                const initAuth = async () => {
                    try {
                        if (typeof window.__initial_auth_token !== 'undefined' && window.__initial_auth_token) {
                            await window.signInWithCustomToken(window.auth, window.__initial_auth_token);
                        } else {
                            await window.signInAnonymously(window.auth);
                        }
                    } catch (e) { console.error("Firebase Auth Error:", e); }
                };
                initAuth();
                try { return window.onAuthStateChanged(window.auth, (u) => setUser(u)); } catch (e) { console.error("Auth listener failed", e); }
            }, []);
            return user;
        };

        // --- Icons ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>);
        const ArrowLeft = (p) => <IconWrapper {...p}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></IconWrapper>;
        const RefreshCcw = (p) => <IconWrapper {...p}><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></IconWrapper>;
        const Trophy = (p) => <IconWrapper {...p}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></IconWrapper>;
        const Info = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></IconWrapper>;
        const AlertCircle = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconWrapper>;
        const Settings = (p) => <IconWrapper {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.35a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconWrapper>;
        const Check = (p) => <IconWrapper {...p}><path d="M20 6 9 17l-5-5"/></IconWrapper>;
        const X = (p) => <IconWrapper {...p}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconWrapper>;
        const Users = (p) => <IconWrapper {...p}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconWrapper>;
        const CloudOff = (p) => <IconWrapper {...p}><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 7h1.8a5 5 0 0 0 5.5 5.5"/><line x1="1" x2="23" y1="1" y2="23"/></IconWrapper>;
        const MessageCircle = (p) => <IconWrapper {...p}><path d="m3 21 1.9-5.7a8.5 8.5 0 1 1 3.8 3.8z" /></IconWrapper>;
        const Send = (p) => <IconWrapper {...p}><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></IconWrapper>;

        // --- Constants & Logic ---
        const PIECE_SIZE_CLASS = "w-8 h-8 sm:w-12 sm:h-12 md:w-14 md:h-14";
        const BOARD_COLOR = "bg-[#eecfa1]";
        const PIECES = {
            RED: { KING: {label:'å¸¥',value:7}, ADVISOR: {label:'ä»•',value:6}, ELEPHANT: {label:'ç›¸',value:5}, ROOK: {label:'ä¿¥',value:4}, HORSE: {label:'å‚Œ',value:3}, CANNON: {label:'ç‚®',value:2}, PAWN: {label:'å…µ',value:1} },
            BLACK: { KING: {label:'å°‡',value:7}, ADVISOR: {label:'å£«',value:6}, ELEPHANT: {label:'è±¡',value:5}, ROOK: {label:'è»Š',value:4}, HORSE: {label:'é¦¬',value:3}, CANNON: {label:'åŒ…',value:2}, PAWN: {label:'å’',value:1} }
        };

        // --- Helper Components ---
        const Piece = ({ type, color, hidden, onClick, selected, lastMove, disabled }) => {
            if (hidden) return <div onClick={onClick} className={`${PIECE_SIZE_CLASS} rounded-full bg-amber-700 border-4 border-amber-800 shadow-lg flex items-center justify-center cursor-pointer hover:scale-105 transition-transform relative pointer-events-auto`}><div className="w-full h-full rounded-full border border-white/20" /></div>;
            const isRed = color === 'red';
            const baseStyle = "rounded-full shadow-lg flex items-center justify-center cursor-pointer select-none relative transition-all duration-200 z-10 pointer-events-auto"; 
            const colorStyle = isRed ? "text-red-700 border-red-700" : "text-black border-black";
            const bgStyle = "bg-[#f5deb3]"; 
            const opacityStyle = disabled ? "cursor-not-allowed" : ""; 
            const selectedStyle = selected ? "ring-4 ring-blue-500 scale-110 z-20 shadow-[0_0_20px_rgba(59,130,246,0.8)]" : (disabled ? "" : "hover:scale-105");
            const lastMoveStyle = lastMove ? "ring-2 ring-green-500" : "";
            return (
                <div className={`relative group flex items-center justify-center pointer-events-none w-full h-full ${opacityStyle}`}>
                    {selected && <div className="absolute inset-0 rounded-full animate-ping bg-blue-400 opacity-30 scale-125 z-0 pointer-events-none"></div>}
                    <div onClick={disabled ? undefined : onClick} className={`${PIECE_SIZE_CLASS} ${baseStyle} ${bgStyle} border-4 ${colorStyle} ${selectedStyle} ${lastMoveStyle}`} style={{boxShadow: selected ? "0 0 15px rgba(59,130,246,0.6)" : "inset 0 0 10px rgba(0,0,0,0.2), 2px 2px 5px rgba(0,0,0,0.4)"}}>
                        <div className="absolute inset-1 border border-dashed opacity-30 rounded-full border-current"></div>
                        <span className="font-bold text-xl sm:text-2xl md:text-3xl font-serif">{type}</span>
                    </div>
                </div>
            );
        };

        const DeadPile = ({ title, pieces, isRed }) => (
            <div className="flex flex-col items-center gap-2 bg-stone-900/40 p-3 rounded-xl border border-stone-700/50 w-full xl:w-40 transition-all backdrop-blur-sm">
                <div className={`text-base font-bold tracking-widest border-b border-stone-700/50 pb-1 w-full text-center ${isRed ? 'text-red-400' : 'text-stone-300'}`}>{title} <span className="text-xs opacity-50">({pieces.length})</span></div>
                <div className="flex flex-wrap gap-2 justify-center content-start min-h-[60px]">
                    {pieces.length === 0 ? <div className="text-stone-600 text-sm py-4 italic opacity-50">æš«ç„¡</div> : pieces.map((p, i) => (
                        <div key={i} className={`w-10 h-10 md:w-12 md:h-12 rounded-full border-4 shadow-sm flex items-center justify-center relative bg-[#eecfa1] ${p.color === 'red' ? 'border-red-800 text-red-800' : 'border-black text-black'} opacity-90`}>
                            <div className="absolute inset-0 rounded-full bg-black/10"></div><span className="font-bold text-lg md:text-xl font-serif select-none">{p.type}</span>
                        </div>
                    ))}
                </div>
            </div>
        );

        const CaptureEffect = ({ piece }) => {
            if (!piece) return null;
            const isRed = piece.color === 'red';
            return <div className="absolute inset-0 z-50 flex items-center justify-center pointer-events-none animate-ping-slow"><div className={`${PIECE_SIZE_CLASS} rounded-full border-4 shadow-xl flex items-center justify-center ${isRed ? "text-red-700 border-red-700" : "text-black border-black"} bg-[#f5deb3] opacity-80 scale-125`}><span className="font-bold text-xl sm:text-2xl md:text-3xl font-serif">{piece.type}</span></div></div>;
        };

        // --- Chat Component ---
        const ChatWindow = ({ roomId, user }) => {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState("");
            const [isOpen, setIsOpen] = useState(false);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                if (!roomId || !window.isFirebaseConfigured) return;
                const unsub = window.onSnapshot(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', roomId), (doc) => {
                    if (doc.exists() && doc.data().messages) {
                        setMessages(doc.data().messages);
                    }
                });
                return () => unsub();
            }, [roomId]);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages, isOpen]);

            const sendMessage = async (e) => {
                e.preventDefault();
                if (!input.trim() || !user) return;
                const msg = { uid: user.uid, text: input.trim(), timestamp: Date.now() };
                await window.updateDoc(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', roomId), {
                    messages: window.arrayUnion(msg)
                });
                setInput("");
            };

            return (
                <div className={`fixed bottom-4 right-4 z-50 flex flex-col items-end transition-all ${isOpen ? 'w-80 h-96' : 'w-auto h-auto'}`}>
                    {isOpen && (
                        <div className="w-full h-full bg-stone-800/95 border border-stone-600 rounded-xl shadow-2xl flex flex-col overflow-hidden mb-2 backdrop-blur-sm">
                            <div className="p-3 bg-stone-700 font-bold flex justify-between items-center border-b border-stone-600">
                                <span>ğŸ’¬ å°æˆ°èŠå¤©å®¤</span>
                                <button onClick={() => setIsOpen(false)}><X size={18}/></button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-3 space-y-2 scrollbar-thin">
                                {messages.map((m, i) => {
                                    const isMe = m.uid === user.uid;
                                    return (
                                        <div key={i} className={`flex ${isMe ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`max-w-[80%] px-3 py-1.5 rounded-lg text-sm break-words ${isMe ? 'bg-blue-600 text-white rounded-br-none' : 'bg-stone-600 text-stone-200 rounded-bl-none'}`}>
                                                {m.text}
                                            </div>
                                        </div>
                                    );
                                })}
                                <div ref={messagesEndRef} />
                            </div>
                            <form onSubmit={sendMessage} className="p-2 bg-stone-700 flex gap-2">
                                <input 
                                    className="flex-1 bg-stone-900 border border-stone-600 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500" 
                                    value={input} onChange={e => setInput(e.target.value)} placeholder="è¼¸å…¥è¨Šæ¯..." 
                                />
                                <button type="submit" className="bg-blue-600 p-2 rounded hover:bg-blue-500"><Send size={16}/></button>
                            </form>
                        </div>
                    )}
                    {!isOpen && (
                        <button onClick={() => setIsOpen(true)} className="bg-blue-600 p-3 rounded-full shadow-lg hover:bg-blue-500 transition-transform hover:scale-110 relative">
                            <MessageCircle />
                        </button>
                    )}
                </div>
            );
        };

        // --- Rock Paper Scissors Component ---
        const RockPaperScissors = ({ myMove, onMove, status }) => {
            const moves = [
                { id: 'rock', label: 'çŸ³é ­', icon: <div className="text-3xl">âœŠ</div> },
                { id: 'paper', label: 'å¸ƒ', icon: <div className="text-3xl">âœ‹</div> },
                { id: 'scissors', label: 'å‰ªåˆ€', icon: <div className="text-3xl">âœŒï¸</div> }
            ];

            return (
                <div className="absolute inset-0 z-50 bg-stone-900/95 flex flex-col items-center justify-center p-4">
                    <h2 className="text-3xl font-bold text-[#eecfa1] mb-2">æ±ºå®šèª°å…ˆé–‹å§‹</h2>
                    <p className="text-stone-400 mb-8">{status === 'waiting' ? 'ç­‰å¾…å°æ‰‹å‡ºæ‹³...' : (status === 'result' ? 'çµæœåˆ¤å®šä¸­...' : 'è«‹å‡ºæ‹³ï¼')}</p>
                    
                    <div className="flex gap-4">
                        {moves.map(m => (
                            <button 
                                key={m.id}
                                onClick={() => onMove(m.id)}
                                disabled={myMove !== null}
                                className={`
                                    w-24 h-24 rounded-full flex flex-col items-center justify-center border-4 transition-all
                                    ${myMove === m.id ? 'bg-[#8b4513] border-[#eecfa1] scale-110 shadow-[0_0_20px_#eecfa1]' : 'bg-stone-700 border-stone-500 hover:bg-stone-600'}
                                    ${myMove && myMove !== m.id ? 'opacity-30' : 'opacity-100'}
                                `}
                            >
                                {m.icon}
                                <span className="mt-1 font-bold">{m.label}</span>
                            </button>
                        ))}
                    </div>
                    {myMove && <div className="mt-8 text-xl text-stone-300 animate-pulse">å·²å‡ºæ‹³ï¼Œç­‰å¾…çµæœ...</div>}
                </div>
            );
        };

        // --- Big Board Logic ---
        const BigBoardGame = ({ onBack, onlineMode }) => {
            const getInitialBoard = () => {
                const b = Array(10).fill(null).map(() => Array(9).fill(null));
                b[0] = ['b_rook', 'b_horse', 'b_elephant', 'b_advisor', 'b_king', 'b_advisor', 'b_elephant', 'b_horse', 'b_rook'];
                b[2][1] = 'b_cannon'; b[2][7] = 'b_cannon';
                b[3][0] = 'b_pawn'; b[3][2] = 'b_pawn'; b[3][4] = 'b_pawn'; b[3][6] = 'b_pawn'; b[3][8] = 'b_pawn';
                b[9] = ['r_rook', 'r_horse', 'r_elephant', 'r_advisor', 'r_king', 'r_advisor', 'r_elephant', 'r_horse', 'r_rook'];
                b[7][1] = 'r_cannon'; b[7][7] = 'r_cannon';
                b[6][0] = 'r_pawn'; b[6][2] = 'r_pawn'; b[6][4] = 'r_pawn'; b[6][6] = 'r_pawn'; b[6][8] = 'r_pawn';
                return b;
            };

            const [board, setBoard] = useState(getInitialBoard());
            const [turn, setTurn] = useState('red'); 
            const [selected, setSelected] = useState(null); 
            const [winner, setWinner] = useState(null);
            
            const user = useFirebaseUser();
            const [onlineState, setOnlineState] = useState(null);
            const [myMove, setMyMove] = useState(null); 
            const [iVotedRematch, setIVotedRematch] = useState(false);

            useEffect(() => {
                if (onlineMode && onlineMode.roomId && window.isFirebaseConfigured) {
                    const unsub = window.onSnapshot(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId), (doc) => {
                        if (doc.exists()) {
                            const data = doc.data();
                            setBoard(JSON.parse(data.board));
                            setTurn(data.turn);
                            setWinner(data.winner);
                            setOnlineState(data);
                            
                            // æœ¬åœ°ç‹€æ…‹åŒæ­¥
                            if (data.rpsState?.moves && user && !data.rpsState.moves[user.uid]) setMyMove(null);
                            if (data.rpsState?.moves && user && data.rpsState.moves[user.uid]) setMyMove(data.rpsState.moves[user.uid]);
                            if (data.rematchVotes && user && !data.rematchVotes[user.uid]) setIVotedRematch(false);
                            
                            // ä¸»æ©Ÿç«¯æª¢æ¸¬æ˜¯å¦éœ€è¦é€²è¡Œ RPS è£æ±º (Host Only)
                            if (data.status === 'rps' && data.rpsState?.moves && user && data.players.host === user.uid) {
                                const moves = data.rpsState.moves;
                                const playerIds = Object.keys(moves);
                                if (playerIds.length === 2 && !data.isResolvingRPS) {
                                    resolveRPS(data);
                                }
                            }
                        }
                    });
                    return () => unsub();
                }
            }, [onlineMode]);

            // Host resolves RPS result to avoid race condition
            const resolveRPS = async (data) => {
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                // Mark as resolving to prevent loop
                // (In a real app, this should be cloud function, but here host does it)
                
                const moves = data.rpsState.moves;
                const [p1, p2] = Object.keys(moves);
                const m1 = moves[p1], m2 = moves[p2];

                if (m1 === m2) {
                    // Draw
                    setTimeout(async () => await window.updateDoc(roomRef, { 'rpsState.moves': {} }), 1500);
                } else {
                    const winnerId = ((m1 === 'rock' && m2 === 'scissors') || (m1 === 'scissors' && m2 === 'paper') || (m1 === 'paper' && m2 === 'rock')) ? p1 : p2;
                    const loserId = winnerId === p1 ? p2 : p1;
                    setTimeout(async () => {
                        await window.updateDoc(roomRef, {
                            status: 'playing',
                            colors: { [winnerId]: 'red', [loserId]: 'black' },
                            turn: 'red'
                        });
                    }, 1000);
                }
            };

            const isMyTurn = () => {
                if (!onlineMode) return true;
                if (!onlineState) return false;
                const myColor = (onlineState.colors && onlineState.colors[user?.uid]) || (onlineState.players.host === user?.uid ? 'red' : 'black');
                return turn === myColor;
            };

            const handleRPSMove = async (move) => {
                if (!user || !onlineMode) return;
                setMyMove(move);
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                // Atomic update to avoid race condition
                await window.updateDoc(roomRef, {
                    [`rpsState.moves.${user.uid}`]: move
                });
            };

            const handleVoteRematch = async () => {
                if (!user || !onlineMode) return;
                setIVotedRematch(true);
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                await window.updateDoc(roomRef, { [`rematchVotes.${user.uid}`]: true });

                // Check if both voted (optimistic local check, but host or last voter triggers reset)
                const currentVotes = { ...(onlineState.rematchVotes || {}), [user.uid]: true };
                if (Object.keys(currentVotes).length === 2) {
                    setTimeout(async () => {
                        await window.updateDoc(roomRef, {
                            board: JSON.stringify(getInitialBoard()),
                            turn: 'red',
                            winner: null,
                            status: 'rps',
                            rematchVotes: {},
                            rpsState: { moves: {} },
                            deadPieces: JSON.stringify({red:[], black:[]}),
                            colors: {}
                        });
                    }, 500);
                }
            };

            const updateRemote = async (newBoard, newTurn, newWinner) => {
                if (!onlineMode || !window.isFirebaseConfigured) return;
                await window.updateDoc(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId), {
                    board: JSON.stringify(newBoard),
                    turn: newTurn,
                    winner: newWinner || null
                });
            };

            const getPieceInfo = (code) => {
                if (!code) return null;
                const [cShort, t] = code.split('_');
                const c = cShort === 'r' ? 'red' : 'black';
                const s = c === 'red' ? PIECES.RED : PIECES.BLACK;
                let l = '';
                if (t === 'king') l = s.KING.label; else if (t === 'advisor') l = s.ADVISOR.label; else if (t === 'elephant') l = s.ELEPHANT.label;
                else if (t === 'horse') l = s.HORSE.label; else if (t === 'rook') l = s.ROOK.label; else if (t === 'cannon') l = s.CANNON.label;
                else if (t === 'pawn') l = s.PAWN.label;
                return { color: c, type: l, label: l };
            };

            const isValidMove = (startX, startY, endX, endY, pieceCode, currentBoard) => {
                const dx = endX - startX, dy = endY - startY, absDx = Math.abs(dx), absDy = Math.abs(dy);
                const [c, type] = pieceCode.split('_');
                const isRed = c === 'r';
                const target = currentBoard[endY][endX];
                if (target && target.startsWith(c)) return false;

                switch (type) {
                    case 'king': return (absDx + absDy === 1) && (endX >= 3 && endX <= 5) && (isRed ? endY >= 7 : endY <= 2);
                    case 'advisor': return (absDx === 1 && absDy === 1) && (endX >= 3 && endX <= 5) && (isRed ? endY >= 7 : endY <= 2);
                    case 'elephant': 
                        if (absDx !== 2 || absDy !== 2) return false;
                        if (isRed && endY < 5) return false; if (!isRed && endY > 4) return false;
                        return !currentBoard[(startY + endY) / 2][(startX + endX) / 2];
                    case 'horse': 
                        if (!((absDx === 1 && absDy === 2) || (absDx === 2 && absDy === 1))) return false;
                        return absDx === 2 ? !currentBoard[startY][(startX + endX) / 2] : !currentBoard[(startY + endY) / 2][startX];
                    case 'rook': 
                        if (startX !== endX && startY !== endY) return false;
                        if (startX === endX) { for(let i = Math.min(startY, endY) + 1; i < Math.max(startY, endY); i++) if(currentBoard[i][startX]) return false; }
                        else { for(let i = Math.min(startX, endX) + 1; i < Math.max(startX, endX); i++) if(currentBoard[startY][i]) return false; }
                        return true;
                    case 'cannon': 
                        if (startX !== endX && startY !== endY) return false;
                        let obs = 0;
                        if (startX === endX) { for(let i = Math.min(startY, endY) + 1; i < Math.max(startY, endY); i++) if(currentBoard[i][startX]) obs++; }
                        else { for(let i = Math.min(startX, endX) + 1; i < Math.max(startX, endX); i++) if(currentBoard[startY][i]) obs++; }
                        return target ? obs === 1 : obs === 0;
                    case 'pawn': 
                        if (absDx + absDy !== 1) return false;
                        if (isRed) { if (endY > startY) return false; if (startY >= 5 && startX !== endX) return false; }
                        else { if (endY < startY) return false; if (startY <= 4 && startX !== endX) return false; }
                        return true;
                    default: return false;
                }
            };

            const handleSquareClick = async (x, y) => {
                if (winner) return;
                if (onlineMode) {
                    if (onlineState?.status !== 'playing') return;
                    if (!isMyTurn()) return;
                }

                const clickedPiece = board[y][x];
                const isMyPiece = clickedPiece && clickedPiece.startsWith(turn === 'red' ? 'r' : 'b');

                if (isMyPiece) {
                    setSelected({ x, y });
                    return;
                }

                if (selected) {
                    const pieceToMove = board[selected.y][selected.x];
                    if (isValidMove(selected.x, selected.y, x, y, pieceToMove, board)) {
                        const newBoard = board.map(r => [...r]);
                        let newWinner = null;
                        if (clickedPiece && clickedPiece.includes('king')) {
                            newWinner = turn;
                            setWinner(turn);
                        }
                        newBoard[y][x] = pieceToMove;
                        newBoard[selected.y][selected.x] = null;
                        const nextTurn = turn === 'red' ? 'black' : 'red';

                        if (onlineMode) {
                            await updateRemote(newBoard, nextTurn, newWinner);
                        } else {
                            setBoard(newBoard);
                            setTurn(nextTurn);
                        }
                        setSelected(null);
                    }
                }
            };

            const resetGame = async () => {
                if (onlineMode) return; 
                setBoard(getInitialBoard()); setTurn('red'); setWinner(null); setSelected(null);
            };

            let statusText = "";
            if (winner) statusText = (winner === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹') + ' ç²å‹!';
            else if (onlineMode && onlineState?.status === 'waiting') statusText = "ç­‰å¾…å°æ‰‹åŠ å…¥...";
            else if (onlineMode && onlineState?.status === 'rps') statusText = "å‰ªåˆ€çŸ³é ­å¸ƒ...";
            else if (onlineMode && !isMyTurn()) statusText = "å°æ‰‹æ€è€ƒä¸­...";
            else statusText = `è¼ªåˆ°: ${turn === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}`;

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-stone-100 p-2 relative">
                    {onlineMode && <ChatWindow roomId={onlineMode.roomId} user={user} />}
                    
                    {onlineMode && onlineState?.status === 'rps' && (
                        <RockPaperScissors myMove={myMove} onMove={handleRPSMove} status={myMove ? 'waiting' : 'play'} />
                    )}

                    <div className="flex w-full max-w-2xl justify-between items-center mb-4">
                        <button onClick={onBack} className="flex items-center gap-2 px-3 py-2 bg-gray-200 rounded hover:bg-gray-300 transition text-sm sm:text-base"><ArrowLeft size={20} /> è¿”å›</button>
                        <div className="text-xl sm:text-2xl font-bold text-stone-800 flex items-center gap-2">
                            {winner && <Trophy className="text-yellow-600"/>}
                            {statusText}
                        </div>
                        {!onlineMode && <button onClick={resetGame} className="p-2 bg-gray-200 rounded hover:bg-gray-300 transition"><RefreshCcw size={20} /></button>}
                        {onlineMode && <div className="w-10"></div>}
                    </div>
                    <div className={`relative ${BOARD_COLOR} p-2 sm:p-4 rounded shadow-2xl select-none`} style={{ width: '100%', maxWidth: '600px', aspectRatio: '9/10' }}>
                        <div className="w-full h-full border-2 border-stone-800 relative grid grid-rows-10 grid-cols-9">
                            <div className="absolute top-[44.44%] left-0 w-full h-[11.11%] flex items-center justify-center pointer-events-none z-0"><div className="absolute top-2 bottom-2 left-2 right-2 border-t-2 border-b-2 border-stone-800/80 bg-stone-500/10"></div><div className="relative z-10 flex w-full justify-around px-8 sm:px-16 text-stone-800/60 font-serif text-2xl sm:text-4xl font-bold tracking-widest"><span>æ¥š æ²³</span><span>æ¼¢ ç•Œ</span></div></div>
                            <svg className="absolute inset-0 w-full h-full pointer-events-none z-0" style={{ opacity: 0.3 }}><line x1="37.5%" y1="0%" x2="62.5%" y2="22.22%" stroke="black" strokeWidth="2" /><line x1="62.5%" y1="0%" x2="37.5%" y2="22.22%" stroke="black" strokeWidth="2" /><line x1="37.5%" y1="77.78%" x2="62.5%" y2="100%" stroke="black" strokeWidth="2" /><line x1="62.5%" y1="77.78%" x2="37.5%" y2="100%" stroke="black" strokeWidth="2" /></svg>
                            {Array(9).fill(0).map((_, x) => (<div key={`v-${x}`} className="absolute top-0 bottom-0 pointer-events-none" style={{ left: `${x * 12.5}%` }}><div className="absolute top-0 h-[44.44%] border-l border-stone-800 w-0"></div><div className="absolute bottom-0 h-[44.44%] border-l border-stone-800 w-0"></div>{(x === 0 || x === 8) && <div className="absolute top-[44.44%] h-[11.11%] border-l border-stone-800 w-0"></div>}</div>))}
                            {Array(10).fill(0).map((_, y) => (<div key={`h-${y}`} className="absolute left-0 right-0 border-t border-stone-800" style={{ top: `${y * 11.1111}%` }}></div>))}
                            <div className="absolute inset-0 z-10">
                                {board.map((row, y) => row.map((code, x) => {
                                    const info = getPieceInfo(code);
                                    const isSelected = selected && selected.x === x && selected.y === y;
                                    const style = { position: 'absolute', left: `${x * 12.5}%`, top: `${y * 11.1111}%`, width: '12.5%', height: '11.1111%', transform: 'translate(-50%, -50%)', display: 'flex', alignItems: 'center', justifyContent: 'center' };
                                    if (!info && !isSelected) return <div key={`${x}-${y}`} style={style} onClick={() => handleSquareClick(x, y)} className="cursor-pointer z-0" />;
                                    if (!info) return <div key={`${x}-${y}`} style={style} onClick={() => handleSquareClick(x, y)} className="cursor-pointer z-0" />;
                                    return <div key={`${x}-${y}`} style={style} className="z-10 pointer-events-none"><Piece type={info.label} color={info.color} selected={isSelected} onClick={() => handleSquareClick(x, y)} /></div>;
                                }))}
                            </div>
                        </div>
                        {winner && onlineMode && (
                            <div className="absolute inset-0 bg-black/60 flex items-center justify-center rounded z-50">
                                <button 
                                    onClick={handleVoteRematch}
                                    disabled={iVotedRematch}
                                    className={`px-8 py-4 text-2xl font-bold rounded shadow-xl transition transform hover:scale-105 ${iVotedRematch ? 'bg-green-600 text-white cursor-default' : 'bg-yellow-500 hover:bg-yellow-400 text-stone-900'}`}
                                >
                                    {iVotedRematch ? "ç­‰å¾…å°æ‰‹ç¢ºèª..." : "å†ä¾†ä¸€å±€"}
                                </button>
                            </div>
                        )}
                    </div>
                    {onlineMode && <div className="mt-2 text-stone-500 text-sm">æˆ¿é–“ ID: <span className="font-mono font-bold select-all">{onlineMode.roomId}</span></div>}
                </div>
            );
        };

        // --- Small Board Logic ---
        const SmallBoardGame = ({ onBack, onlineMode }) => {
            const [pieces, setPieces] = useState([]);
            const [board, setBoard] = useState(Array(32).fill(null)); 
            const [turn, setTurn] = useState(null); 
            const [selectedIdx, setSelectedIdx] = useState(null);
            const [winner, setWinner] = useState(null);
            const [myColor, setMyColor] = useState(null); 
            const [deadPieces, setDeadPieces] = useState({ red: [], black: [] });
            const [message, setMessage] = useState(null); 
            const [captureAnim, setCaptureAnim] = useState(null); 
            
            const [showSetup, setShowSetup] = useState(!onlineMode); 
            const [rules, setRules] = useState({ canCaptureUnrevealed: false, allowContinuousCapture: false });
            const [continuousState, setContinuousState] = useState({ active: false, pieceIdx: null });

            const user = useFirebaseUser();
            const [onlineState, setOnlineState] = useState(null);
            const [myMove, setMyMove] = useState(null); 
            const [iVotedRematch, setIVotedRematch] = useState(false);

            // --- Online Logic ---
            useEffect(() => {
                if (onlineMode && onlineMode.roomId && window.isFirebaseConfigured) {
                    try {
                        const unsub = window.onSnapshot(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId), (doc) => {
                            if (doc.exists()) {
                                const data = doc.data();
                                setBoard(JSON.parse(data.board));
                                setTurn(data.turn);
                                setWinner(data.winner);
                                setDeadPieces(JSON.parse(data.deadPieces));
                                setRules(data.rules);
                                setContinuousState(data.continuousState);
                                setOnlineState(data);
                                
                                if (data.rpsState?.moves && user && !data.rpsState.moves[user.uid]) setMyMove(null);
                                if (data.rpsState?.moves && user && data.rpsState.moves[user.uid]) setMyMove(data.rpsState.moves[user.uid]);
                                if (data.rematchVotes && user && !data.rematchVotes[user.uid]) setIVotedRematch(false);

                                if (data.colors && user) {
                                    if (data.colors[user.uid]) {
                                        setMyColor(data.colors[user.uid]);
                                    }
                                }
                                
                                // Host Resolves RPS (Same as BigBoard)
                                if (data.status === 'rps' && data.rpsState?.moves && user && data.players.host === user.uid) {
                                    const moves = data.rpsState.moves;
                                    const playerIds = Object.keys(moves);
                                    if (playerIds.length === 2) {
                                        resolveRPS(data);
                                    }
                                }
                            }
                        });
                        return () => unsub();
                    } catch(e) { console.error("Snapshot failed", e); }
                }
            }, [onlineMode, user]);

            const resolveRPS = async (data) => {
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                const moves = data.rpsState.moves;
                const [p1, p2] = Object.keys(moves);
                const m1 = moves[p1], m2 = moves[p2];

                if (m1 === m2) {
                    setTimeout(async () => await window.updateDoc(roomRef, { 'rpsState.moves': {} }), 1500);
                } else {
                    const winnerId = ((m1 === 'rock' && m2 === 'scissors') || (m1 === 'scissors' && m2 === 'paper') || (m1 === 'paper' && m2 === 'rock')) ? p1 : p2;
                    setTimeout(async () => {
                        await window.updateDoc(roomRef, {
                            status: 'playing',
                            firstPlayer: winnerId,
                            turn: null
                        });
                    }, 1000);
                }
            };

            const handleRPSMove = async (move) => {
                if (!user || !onlineMode) return;
                setMyMove(move);
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                await window.updateDoc(roomRef, { [`rpsState.moves.${user.uid}`]: move });
            };

            const handleVoteRematch = async () => {
                if (!user || !onlineMode) return;
                setIVotedRematch(true);
                const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId);
                await window.updateDoc(roomRef, { [`rematchVotes.${user.uid}`]: true });

                const currentVotes = { ...(onlineState.rematchVotes || {}), [user.uid]: true };
                if (Object.keys(currentVotes).length === 2) {
                    // Reshuffle logic
                    const p = [];
                    const add = (color, typeObj, count) => { for(let i=0; i<count; i++) p.push({ id: `${color}-${typeObj.label}-${i}`, color, type: typeObj.label, value: typeObj.value, revealed: false, dead: false }); };
                    add('red', PIECES.RED.KING, 1); add('red', PIECES.RED.ADVISOR, 2); add('red', PIECES.RED.ELEPHANT, 2); add('red', PIECES.RED.ROOK, 2); add('red', PIECES.RED.HORSE, 2); add('red', PIECES.RED.CANNON, 2); add('red', PIECES.RED.PAWN, 5);
                    add('black', PIECES.BLACK.KING, 1); add('black', PIECES.BLACK.ADVISOR, 2); add('black', PIECES.BLACK.ELEPHANT, 2); add('black', PIECES.BLACK.ROOK, 2); add('black', PIECES.BLACK.HORSE, 2); add('black', PIECES.BLACK.CANNON, 2); add('black', PIECES.BLACK.PAWN, 5);
                    for (let i = p.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }

                    setTimeout(async () => {
                        await window.updateDoc(roomRef, {
                            board: JSON.stringify(p),
                            turn: null,
                            winner: null,
                            status: 'rps',
                            rematchVotes: {},
                            rpsState: { moves: {} },
                            deadPieces: JSON.stringify({red:[], black:[]}),
                            continuousState: { active: false, pieceIdx: null },
                            colors: {}
                        });
                    }, 500);
                }
            };

            const showMessage = (msg) => { setMessage(msg); setTimeout(() => setMessage(null), 2000); };

            const canIAct = () => {
                if (!onlineMode) return true; 
                if (onlineState?.status !== 'playing') return false;
                if (!turn) {
                    return onlineState.firstPlayer === user.uid;
                }
                if (myColor && turn === myColor) return true;
                return false;
            };

            const updateRemote = async (updates) => {
                if (!onlineMode || !window.isFirebaseConfigured) return;
                try {
                    await window.updateDoc(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', onlineMode.roomId), updates);
                } catch(e) { console.error("Update failed:", e); }
            };

            const initGame = async (customRules = rules) => {
                const p = [];
                const add = (color, typeObj, count) => { for(let i=0; i<count; i++) p.push({ id: `${color}-${typeObj.label}-${i}`, color, type: typeObj.label, value: typeObj.value, revealed: false, dead: false }); };
                add('red', PIECES.RED.KING, 1); add('red', PIECES.RED.ADVISOR, 2); add('red', PIECES.RED.ELEPHANT, 2); add('red', PIECES.RED.ROOK, 2); add('red', PIECES.RED.HORSE, 2); add('red', PIECES.RED.CANNON, 2); add('red', PIECES.RED.PAWN, 5);
                add('black', PIECES.BLACK.KING, 1); add('black', PIECES.BLACK.ADVISOR, 2); add('black', PIECES.BLACK.ELEPHANT, 2); add('black', PIECES.BLACK.ROOK, 2); add('black', PIECES.BLACK.HORSE, 2); add('black', PIECES.BLACK.CANNON, 2); add('black', PIECES.BLACK.PAWN, 5);
                for (let i = p.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }

                const initialState = {
                    board: p, turn: null, winner: null, deadPieces: { red: [], black: [] },
                    continuousState: { active: false, pieceIdx: null }
                };

                if (!onlineMode) {
                    setPieces(p); setBoard(p); setTurn(null); setMyColor(null); setSelectedIdx(null); setWinner(null); setDeadPieces({ red: [], black: [] }); setMessage(null); setCaptureAnim(null); setContinuousState({ active: false, pieceIdx: null }); setRules(customRules); setShowSetup(false);
                }
            };

            const getXY = (index) => ({ x: index % 8, y: Math.floor(index / 8) });
            const getIndex = (x, y) => y * 8 + x;
            const canMove = (fromIdx, toIdx, isCannon) => {
                const from = getXY(fromIdx), to = getXY(toIdx), dx = Math.abs(from.x - to.x), dy = Math.abs(from.y - to.y), dist = dx + dy;
                if (isCannon) {
                    if (from.x !== to.x && from.y !== to.y) return false; 
                    let obstacles = 0;
                    if (from.x === to.x) { for(let y = Math.min(from.y, to.y) + 1; y < Math.max(from.y, to.y); y++) if(board[getIndex(from.x, y)]) obstacles++; }
                    else { for(let x = Math.min(from.x, to.x) + 1; x < Math.max(from.x, to.x); x++) if(board[getIndex(x, from.y)]) obstacles++; }
                    return obstacles === 1;
                }
                return dist === 1;
            };
            const canEat = (attacker, defender) => {
                if (attacker.color === defender.color) return false;
                if (attacker.value === 2) return true;
                if ((attacker.value === 1 && defender.value === 7)) return true;
                if ((attacker.value === 7 && defender.value === 1)) return false;
                return attacker.value >= defender.value;
            };

            const handleEndTurn = async () => {
                const nextTurn = turn === 'red' ? 'black' : 'red';
                const nextContState = { active: false, pieceIdx: null };
                
                if (onlineMode) {
                    await updateRemote({ turn: nextTurn, continuousState: nextContState });
                    setSelectedIdx(null);
                } else {
                    setTurn(nextTurn);
                    setContinuousState(nextContState);
                    setSelectedIdx(null);
                }
            };

            const handleInteraction = async (index) => {
                if (winner) return;
                if (!canIAct()) return; 

                if (continuousState.active) {
                    if (index === continuousState.pieceIdx) { setSelectedIdx(index); return; }
                    const target = board[index];
                    if (target && target.revealed && target.color === turn && index !== continuousState.pieceIdx) {
                        showMessage("é€£åƒæ¨¡å¼ï¼šå¿…é ˆä½¿ç”¨ç•¶å‰æ£‹å­"); return;
                    }
                }

                const targetPiece = board[index];

                // --- 1. Flip (Reveal) ---
                if (targetPiece && !targetPiece.revealed) {
                    if (selectedIdx !== null) {
                        // Capture Unrevealed Logic
                        if (rules.canCaptureUnrevealed) {
                            const attacker = board[selectedIdx];
                            const isCannon = attacker.value === 2;
                            let validMove = true, moveError = "";
                            if (isCannon) { if (!canMove(selectedIdx, index, true)) { moveError = "ç‚®éœ€éš”ä¸€å­æ‰èƒ½åƒ"; validMove = false; } }
                            else { if (!canMove(selectedIdx, index, false)) { moveError = "è·é›¢éé "; validMove = false; } }

                            if (!validMove) { showMessage(moveError); return; }

                            const revealedTarget = { ...targetPiece, revealed: true };
                            // Check valid capture
                            if (revealedTarget.color === turn) {
                                const newBoard = [...board]; newBoard[index] = revealedTarget;
                                await updateGameState(newBoard, null, "ä¸èƒ½åƒè‡ªå·±çš„æ£‹ï¼", true);
                                return;
                            }
                            if (!canEat(attacker, revealedTarget)) {
                                const newBoard = [...board]; newBoard[index] = revealedTarget;
                                await updateGameState(newBoard, null, `éšç´šä¸è¶³`, true);
                                return;
                            }
                            await executeCapture(selectedIdx, index, attacker, revealedTarget);
                            return;
                        } else {
                            showMessage("è¦å‰‡ï¼šä¸èƒ½åƒæœªç¿»é–‹çš„æ£‹å­"); return;
                        }
                    } else {
                        // Just Flip
                        const newBoard = [...board];
                        newBoard[index] = { ...targetPiece, revealed: true };
                        
                        let updates = { board: JSON.stringify(newBoard) };
                        let nextTurn = turn;

                        // Determine Colors if first flip
                        if (!turn) {
                            const flippedColor = newBoard[index].color;
                            nextTurn = flippedColor === 'red' ? 'black' : 'red';
                            updates.turn = nextTurn;
                            
                            if (onlineMode) {
                                // First player (who flipped) gets 'flippedColor'
                                const opponentId = Object.values(onlineState.players).find(id => id !== user.uid);
                                const newColors = {
                                    [user.uid]: flippedColor,
                                    [opponentId || 'guest']: flippedColor === 'red' ? 'black' : 'red'
                                };
                                updates.colors = newColors;
                            } else {
                                setMyColor(flippedColor);
                                setTurn(nextTurn);
                                setBoard(newBoard);
                            }
                        } else {
                            nextTurn = turn === 'red' ? 'black' : 'red';
                            updates.turn = nextTurn;
                            if (!onlineMode) { setTurn(nextTurn); setBoard(newBoard); }
                        }
                        
                        if (onlineMode) await updateRemote(updates);
                        setMessage(null);
                        return;
                    }
                }

                // --- 2. Select Own Piece ---
                if (targetPiece && targetPiece.revealed && targetPiece.color === turn) {
                    if (onlineMode && myColor && myColor !== turn) return; 
                    setSelectedIdx(index); setMessage(null); return;
                }

                // --- 3. Move or Attack ---
                if (selectedIdx !== null) {
                    const attacker = board[selectedIdx];
                    const isCannon = attacker.value === 2;
                    if (!targetPiece) {
                        // Move to empty
                        // ã€é—œéµä¿®æ­£ã€‘é€£åƒæ¨¡å¼ä¸‹ï¼Œç¦æ­¢ç§»å‹•åˆ°ç©ºä½
                        if (continuousState.active) {
                            showMessage("é€£åƒä¸­ï¼šä¸å¯ç§»å‹•è‡³ç©ºä½ï¼Œè«‹ç¹¼çºŒåƒå­æˆ–çµæŸå›åˆ");
                            return;
                        }

                        if (canMove(selectedIdx, index, false)) {
                            const newBoard = [...board]; newBoard[index] = attacker; newBoard[selectedIdx] = null;
                            await updateGameState(newBoard, null, null, true); // End turn normally
                        } else { showMessage("ç„¡æ•ˆçš„ç§»å‹•"); }
                    } else if (targetPiece.revealed && targetPiece.color !== turn) {
                        // Attack Revealed
                        let valid = false, err = "ç„¡æ³•åƒå­";
                        if (isCannon) { if (canMove(selectedIdx, index, true)) valid = true; else err = "ç‚®éœ€éš”ä¸€å­æ‰èƒ½åƒå­"; }
                        else { if (canMove(selectedIdx, index, false)) { if (canEat(attacker, targetPiece)) valid = true; else err = "éšç´šä¸è¶³"; } else err = "è·é›¢éé "; }
                        
                        if (valid) await executeCapture(selectedIdx, index, attacker, targetPiece);
                        else showMessage(err);
                    }
                }
            };

            const updateGameState = async (newBoard, newDeadPieces, msg, switchTurn) => {
                let updates = { board: JSON.stringify(newBoard) };
                if (newDeadPieces) updates.deadPieces = JSON.stringify(newDeadPieces);
                if (switchTurn) {
                    updates.turn = turn === 'red' ? 'black' : 'red';
                    updates.continuousState = { active: false, pieceIdx: null };
                }
                
                if (onlineMode) {
                    await updateRemote(updates);
                    if (msg) showMessage(msg);
                    setSelectedIdx(null);
                } else {
                    setBoard(newBoard);
                    if (newDeadPieces) setDeadPieces(newDeadPieces);
                    if (switchTurn) {
                        setTurn(updates.turn);
                        setContinuousState(updates.continuousState);
                    }
                    if (msg) showMessage(msg);
                    setSelectedIdx(null);
                }
            };

            const executeCapture = async (fromIdx, toIdx, attacker, victim) => {
                setCaptureAnim({ idx: toIdx, piece: victim });
                setTimeout(() => setCaptureAnim(null), 800);

                const newBoard = [...board];
                newBoard[toIdx] = attacker;
                newBoard[fromIdx] = null;

                const deadPiece = { ...victim, revealed: true };
                const newDeadPieces = { ...deadPieces, [deadPiece.color]: [...deadPieces[deadPiece.color], deadPiece] };

                // Check Win
                const enemyColor = turn === 'red' ? 'black' : 'red';
                const remaining = newBoard.filter(p => p && p.color === enemyColor && !p.dead);
                let newWinner = null;
                if (remaining.length === 0) newWinner = turn;

                if (rules.allowContinuousCapture && !newWinner) {
                    // Continuous Logic
                    const newState = { active: true, pieceIdx: toIdx };
                    if (onlineMode) {
                        await updateRemote({
                            board: JSON.stringify(newBoard),
                            deadPieces: JSON.stringify(newDeadPieces),
                            continuousState: newState,
                            winner: newWinner
                        });
                        setSelectedIdx(toIdx);
                        showMessage(`åƒæ‰ ${victim.type}ï¼é€£åƒä¸­`);
                    } else {
                        setBoard(newBoard); setDeadPieces(newDeadPieces); setContinuousState(newState); setWinner(newWinner); setSelectedIdx(toIdx);
                        showMessage(`åƒæ‰ ${victim.type}ï¼é€£åƒä¸­`);
                    }
                } else {
                    // Normal End Turn
                    let updates = { board: JSON.stringify(newBoard), deadPieces: JSON.stringify(newDeadPieces), winner: newWinner || null };
                    if (!newWinner) {
                        updates.turn = turn === 'red' ? 'black' : 'red';
                        updates.continuousState = { active: false, pieceIdx: null };
                    }
                    
                    if (onlineMode) {
                        await updateRemote(updates);
                        setSelectedIdx(null);
                    } else {
                        setBoard(newBoard); setDeadPieces(newDeadPieces); setWinner(newWinner);
                        if (!newWinner) { setTurn(updates.turn); setContinuousState(updates.continuousState); }
                        setSelectedIdx(null);
                    }
                }
            };

            // --- Render ---
            let statusText = "";
            if (winner) statusText = (winner === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹') + ' ç²å‹!';
            else if (onlineMode && onlineState?.status === 'waiting') statusText = "ç­‰å¾…å°æ‰‹åŠ å…¥...";
            else if (onlineMode && onlineState?.status === 'rps') statusText = "å‰ªåˆ€çŸ³é ­å¸ƒ...";
            else if (onlineMode && !canIAct()) statusText = "å°æ‰‹æ€è€ƒä¸­...";
            else if (!turn && onlineMode) statusText = (canIAct() ? "è«‹ç¿»ç‰Œæ±ºå®šé¡è‰²" : "ç­‰å¾…å°æ‰‹ç¿»ç‰Œ"); // Special Small Board state
            else statusText = `è¼ªåˆ°: ${turn === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}`;

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-stone-800 p-2 relative">
                    {onlineMode && <ChatWindow roomId={onlineMode.roomId} user={user} />}
                    
                    {onlineMode && onlineState?.status === 'rps' && (
                        <RockPaperScissors myMove={myMove} onMove={handleRPSMove} status={myMove ? 'waiting' : 'play'} />
                    )}

                    {/* Setup Modal (Local Only) */}
                    {showSetup && !onlineMode && (
                        <div className="absolute inset-0 bg-stone-900/90 z-50 flex items-center justify-center p-4">
                            <div className="bg-[#eecfa1] p-6 sm:p-8 rounded-xl shadow-2xl max-w-sm w-full border-4 border-[#8b4513] text-stone-900">
                                <h2 className="text-2xl font-bold mb-6 text-center border-b-2 border-[#8b4513] pb-2">æ–°å±€è¨­å®š</h2>
                                <div className="space-y-4 mb-8">
                                    <label className="flex items-center justify-between p-3 bg-white/50 rounded-lg cursor-pointer hover:bg-white/70 transition"><span className="font-bold flex items-center gap-2">{rules.canCaptureUnrevealed ? <Check className="text-green-700"/> : <X className="text-stone-400"/>}å¯åƒè“‹ç‰Œ</span><input type="checkbox" className="w-6 h-6 accent-[#8b4513]" checked={rules.canCaptureUnrevealed} onChange={(e) => setRules({...rules, canCaptureUnrevealed: e.target.checked})}/></label>
                                    <label className="flex items-center justify-between p-3 bg-white/50 rounded-lg cursor-pointer hover:bg-white/70 transition"><span className="font-bold flex items-center gap-2">{rules.allowContinuousCapture ? <Check className="text-green-700"/> : <X className="text-stone-400"/>}é€£åƒæ¨¡å¼</span><input type="checkbox" className="w-6 h-6 accent-[#8b4513]" checked={rules.allowContinuousCapture} onChange={(e) => setRules({...rules, allowContinuousCapture: e.target.checked})}/></label>
                                </div>
                                <div className="flex gap-2"><button onClick={() => onBack()} className="flex-1 py-3 bg-stone-500 text-white rounded font-bold hover:bg-stone-600 transition">å–æ¶ˆ</button><button onClick={() => initGame(rules)} className="flex-1 py-3 bg-[#8b4513] text-white rounded font-bold hover:bg-[#6d360f] transition shadow-lg">é–‹å§‹éŠæˆ²</button></div>
                            </div>
                        </div>
                    )}

                    <div className="flex w-full max-w-4xl justify-between items-center mb-4 text-white relative">
                        <button onClick={onBack} className="flex items-center gap-2 px-3 py-2 bg-stone-600 rounded hover:bg-stone-500 transition text-sm"><ArrowLeft size={16} /> è¿”å›</button>
                        <div className="flex flex-col items-center absolute left-1/2 transform -translate-x-1/2 w-full max-w-[280px] pointer-events-none">
                            {message && <div className="mb-2 px-3 py-1 bg-red-600/90 text-white text-sm rounded-full shadow-lg animate-bounce flex items-center gap-1 whitespace-nowrap z-50"><AlertCircle size={14} /> {message}</div>}
                            <div className="text-lg font-bold pointer-events-auto flex flex-col items-center">
                                {winner ? <span className="text-yellow-400 flex items-center gap-2 animate-bounce"><Trophy /> {winner === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'} ç²å‹!</span> : <div className="flex items-center gap-2"><span>{statusText}</span></div>}
                                {continuousState.active && !winner && canIAct() && (<button onClick={handleEndTurn} className="mt-4 px-6 py-2 bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-400 hover:to-red-500 text-white font-bold text-lg rounded-full shadow-lg border-2 border-white/50 animate-flash-button pointer-events-auto flex items-center gap-2 transform transition-all z-50">çµæŸå›åˆ (Pass)</button>)}
                            </div>
                        </div>
                        {!onlineMode && <button onClick={() => setShowSetup(true)} className="p-2 bg-stone-600 rounded hover:bg-stone-500 transition"><Settings size={16} /></button>}
                        {onlineMode && <div className="w-8"></div>}
                    </div>

                    <div className="flex flex-col xl:flex-row gap-6 w-full max-w-7xl justify-center items-start mt-4 px-2">
                        <div className="order-2 xl:order-1 w-full xl:w-auto flex justify-center"><DeadPile title="ç´…æ–¹é™£äº¡" pieces={deadPieces.red} isRed={true} /></div>
                        <div className={`order-1 xl:order-2 shrink-0 grid grid-cols-8 gap-1 sm:gap-2 p-2 sm:p-4 rounded-lg shadow-2xl ${BOARD_COLOR} border-8 border-[#8b4513] mx-auto`}>
                            {board.map((piece, i) => {
                                let disabled = false;
                                if (onlineMode && onlineState?.status !== 'playing') disabled = true;
                                if (onlineMode && !canIAct()) disabled = true;
                                if (continuousState.active) {
                                    const isMyPiece = piece && piece.revealed && piece.color === turn;
                                    if (isMyPiece && i !== continuousState.pieceIdx) {
                                        disabled = true;
                                    }
                                }
                                
                                return (
                                    <div key={i} className="w-10 h-10 sm:w-14 sm:h-14 md:w-20 md:h-20 flex items-center justify-center relative">
                                        <div className="absolute inset-0 border border-stone-800/20 pointer-events-none"></div>
                                        {captureAnim && captureAnim.idx === i && <CaptureEffect piece={captureAnim.piece} />}
                                        {piece ? <Piece type={piece.type} color={piece.color} hidden={!piece.revealed} selected={selectedIdx === i} disabled={disabled} onClick={() => handleInteraction(i)} /> : <div onClick={() => handleInteraction(i)} className="w-full h-full cursor-pointer hover:bg-black/5 transition-colors" />}
                                    </div>
                                );
                            })}
                        </div>
                        <div className="order-3 w-full xl:w-auto flex justify-center"><DeadPile title="é»‘æ–¹é™£äº¡" pieces={deadPieces.black} isRed={false} /></div>
                        {winner && onlineMode && (
                            <div className="absolute inset-0 bg-black/60 flex items-center justify-center rounded z-50">
                                <button 
                                    onClick={handleVoteRematch}
                                    disabled={iVotedRematch}
                                    className={`px-8 py-4 text-2xl font-bold rounded shadow-xl transition transform hover:scale-105 ${iVotedRematch ? 'bg-green-600 text-white cursor-default' : 'bg-yellow-500 hover:bg-yellow-400 text-stone-900'}`}
                                >
                                    {iVotedRematch ? "ç­‰å¾…å°æ‰‹ç¢ºèª..." : "å†ä¾†ä¸€å±€"}
                                </button>
                            </div>
                        )}
                    </div>
                    {onlineMode && <div className="mt-2 text-stone-500 text-sm">æˆ¿é–“ ID: <span className="font-mono font-bold select-all">{onlineMode.roomId}</span></div>}
                </div>
            );
        };

        const OnlineLobby = ({ onBack, onJoinGame }) => {
            const [mode, setMode] = useState('menu'); 
            const [roomIdInput, setRoomIdInput] = useState('');
            const [isCreating, setIsCreating] = useState(false);
            const [rules, setRules] = useState({ canCaptureUnrevealed: false, allowContinuousCapture: false });
            const [gameType, setGameType] = useState('small'); 

            const user = useFirebaseUser();

            // å¦‚æœ Firebase æ²’é…ç½®ï¼Œé¡¯ç¤ºéŒ¯èª¤ UI
            if (!window.isFirebaseConfigured) {
                return (
                    <div className="min-h-screen bg-stone-900 flex flex-col items-center justify-center p-4 text-stone-100">
                        <div className="bg-stone-800 p-8 rounded-xl border border-stone-600 max-w-md text-center">
                            <div className="flex justify-center mb-4"><CloudOff size={64} className="text-stone-500"/></div>
                            <h2 className="text-2xl font-bold mb-4">ç„¡æ³•é€£æ¥ç·šä¸Šä¼ºæœå™¨</h2>
                            <p className="text-stone-400 mb-6">æª¢æ¸¬åˆ°æ­¤æª”æ¡ˆæ­£æ–¼æœ¬æ©Ÿç’°å¢ƒåŸ·è¡Œï¼Œä¸”ç¼ºå°‘ Firebase é…ç½®é‡‘é‘°ã€‚ç·šä¸Šå°æˆ°åŠŸèƒ½éœ€è¦å¾Œç«¯æ”¯æ´ã€‚</p>
                            <p className="text-stone-500 text-sm mb-6">è‹¥è¦å•Ÿç”¨æ­¤åŠŸèƒ½ï¼Œéœ€åœ¨ index.html ä¸­è¨­å®š window.__firebase_configã€‚</p>
                            <button onClick={onBack} className="bg-stone-600 px-6 py-2 rounded-lg hover:bg-stone-500 transition">è¿”å›ä¸»é¸å–®</button>
                        </div>
                    </div>
                );
            }

            const generateRoomId = () => Math.floor(100000 + Math.random() * 900000).toString();

            const createRoom = async () => {
                if (!user) return;
                setIsCreating(true);
                try {
                    let initialBoardStr = "";
                    let initialDead = JSON.stringify({red:[], black:[]});
                    
                    if (gameType === 'small') {
                        const p = [];
                        const add = (color, typeObj, count) => { for(let i=0; i<count; i++) p.push({ id: `${color}-${typeObj.label}-${i}`, color, type: typeObj.label, value: typeObj.value, revealed: false, dead: false }); };
                        add('red', PIECES.RED.KING, 1); add('red', PIECES.RED.ADVISOR, 2); add('red', PIECES.RED.ELEPHANT, 2); add('red', PIECES.RED.ROOK, 2); add('red', PIECES.RED.HORSE, 2); add('red', PIECES.RED.CANNON, 2); add('red', PIECES.RED.PAWN, 5);
                        add('black', PIECES.BLACK.KING, 1); add('black', PIECES.BLACK.ADVISOR, 2); add('black', PIECES.BLACK.ELEPHANT, 2); add('black', PIECES.BLACK.ROOK, 2); add('black', PIECES.BLACK.HORSE, 2); add('black', PIECES.BLACK.CANNON, 2); add('black', PIECES.BLACK.PAWN, 5);
                        for (let i = p.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
                        initialBoardStr = JSON.stringify(p);
                    } else {
                        const b = Array(10).fill(null).map(() => Array(9).fill(null));
                        b[0] = ['b_rook', 'b_horse', 'b_elephant', 'b_advisor', 'b_king', 'b_advisor', 'b_elephant', 'b_horse', 'b_rook']; b[2][1] = 'b_cannon'; b[2][7] = 'b_cannon'; b[3][0] = 'b_pawn'; b[3][2] = 'b_pawn'; b[3][4] = 'b_pawn'; b[3][6] = 'b_pawn'; b[3][8] = 'b_pawn';
                        b[9] = ['r_rook', 'r_horse', 'r_elephant', 'r_advisor', 'r_king', 'r_advisor', 'r_elephant', 'r_horse', 'r_rook']; b[7][1] = 'r_cannon'; b[7][7] = 'r_cannon'; b[6][0] = 'r_pawn'; b[6][2] = 'r_pawn'; b[6][4] = 'r_pawn'; b[6][6] = 'r_pawn'; b[6][8] = 'r_pawn';
                        initialBoardStr = JSON.stringify(b);
                    }

                    const roomId = generateRoomId();
                    await window.setDoc(window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', roomId), {
                        createdAt: window.serverTimestamp(),
                        gameType,
                        rules: gameType === 'small' ? rules : {},
                        players: { host: user.uid },
                        status: 'waiting',
                        board: initialBoardStr,
                        turn: 'red',
                        deadPieces: initialDead,
                        continuousState: { active: false, pieceIdx: null },
                        rpsState: { moves: {} }, // Init RPS state
                        colors: gameType === 'big' ? { [user.uid]: 'red' } : {},
                        messages: [] // Chat messages
                    });
                    
                    onJoinGame({ roomId: roomId, gameType });
                } catch (e) {
                    console.error(e);
                    alert("å»ºç«‹æˆ¿é–“å¤±æ•—: " + e.code + " (" + e.message + ")\nè«‹æª¢æŸ¥ Firebase Firestore è¦å‰‡æ˜¯å¦è¨­ç‚º Test Modeã€‚");
                }
                setIsCreating(false);
            };

            const joinRoom = async () => {
                if (!roomIdInput) return;
                try {
                    const roomRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'rooms', roomIdInput);
                    const snap = await window.getDoc(roomRef);
                    if (snap.exists()) {
                        const data = snap.data();
                        
                        if (data.players.host === user.uid) {
                            alert("âš ï¸ æ‚¨æ˜¯æ­¤æˆ¿é–“çš„æˆ¿ä¸»ï¼\n\nè‹¥è¦æ¸¬è©¦å°æˆ°ï¼Œè«‹é–‹å•Ÿã€Œç„¡ç—•è¦–çª— (Incognito)ã€æˆ–ä½¿ç”¨ã€Œå¦ä¸€å€‹ç€è¦½å™¨ã€ä¾†æ¨¡æ“¬ç¬¬äºŒä½ç©å®¶åŠ å…¥ã€‚");
                            onJoinGame({ roomId: roomIdInput, gameType: data.gameType });
                            return;
                        }

                        if (data.status !== 'waiting' && (!data.players.guest || data.players.guest !== user.uid) && data.players.host !== user.uid) {
                            alert("æˆ¿é–“å·²æ»¿æˆ–éŠæˆ²é€²è¡Œä¸­");
                            return;
                        }
                        if (data.players.host !== user.uid) {
                            await window.updateDoc(roomRef, {
                                'players.guest': user.uid,
                                status: 'rps', // Start RPS phase
                                ...(data.gameType === 'big' ? { ['colors.' + user.uid]: 'black' } : {})
                            });
                        }
                        onJoinGame({ roomId: roomIdInput, gameType: data.gameType });
                    } else {
                        alert("æˆ¿é–“ä¸å­˜åœ¨ (æˆ–ç„¡æ¬Šé™å­˜å–)");
                    }
                } catch (e) {
                    console.error(e);
                    alert("åŠ å…¥å¤±æ•—: " + e.code + "\nè«‹ç¢ºèªç¶²è·¯é€£ç·šæˆ– Firebase æ¬Šé™ã€‚");
                }
            };

            return (
                <div className="min-h-screen bg-stone-900 flex flex-col items-center justify-center p-4 text-stone-100">
                    <h1 className="text-3xl font-serif font-bold text-[#eecfa1] mb-8 tracking-widest">ç·šä¸Šå°æˆ°å¤§å»³</h1>
                    
                    {mode === 'menu' && (
                        <div className="flex flex-col gap-4 w-full max-w-xs">
                            <button onClick={() => setMode('create')} className="bg-[#8b4513] py-4 rounded-xl font-bold shadow-lg hover:bg-[#6d360f] transition">å»ºç«‹æˆ¿é–“</button>
                            <button onClick={() => setMode('join')} className="bg-stone-700 py-4 rounded-xl font-bold shadow-lg hover:bg-stone-600 transition">åŠ å…¥æˆ¿é–“</button>
                            <button onClick={onBack} className="mt-4 text-stone-500 hover:text-stone-300">è¿”å›ä¸»é¸å–®</button>
                        </div>
                    )}

                    {mode === 'create' && (
                        <div className="bg-[#eecfa1] p-6 rounded-xl shadow-2xl max-w-sm w-full border-4 border-[#8b4513] text-stone-900">
                            <h2 className="text-xl font-bold mb-4 text-center">å»ºç«‹æ–°å±€</h2>
                            <div className="flex gap-2 mb-4">
                                <button onClick={() => setGameType('big')} className={`flex-1 py-2 rounded font-bold ${gameType === 'big' ? 'bg-[#8b4513] text-white' : 'bg-white/50'}`}>å¤§ç›¤</button>
                                <button onClick={() => setGameType('small')} className={`flex-1 py-2 rounded font-bold ${gameType === 'small' ? 'bg-[#8b4513] text-white' : 'bg-white/50'}`}>å°ç›¤</button>
                            </div>
                            
                            {gameType === 'small' && (
                                <div className="space-y-2 mb-6">
                                    <label className="flex items-center justify-between p-2 bg-white/50 rounded cursor-pointer"><span className="text-sm font-bold">å¯åƒè“‹ç‰Œ</span><input type="checkbox" className="accent-[#8b4513]" checked={rules.canCaptureUnrevealed} onChange={(e) => setRules({...rules, canCaptureUnrevealed: e.target.checked})}/></label>
                                    <label className="flex items-center justify-between p-2 bg-white/50 rounded cursor-pointer"><span className="text-sm font-bold">é€£åƒæ¨¡å¼</span><input type="checkbox" className="accent-[#8b4513]" checked={rules.allowContinuousCapture} onChange={(e) => setRules({...rules, allowContinuousCapture: e.target.checked})}/></label>
                                </div>
                            )}

                            <button onClick={createRoom} disabled={isCreating} className="w-full py-3 bg-[#8b4513] text-white rounded font-bold hover:bg-[#6d360f] transition shadow-lg mb-2">
                                {isCreating ? "å»ºç«‹ä¸­..." : "ç¢ºèªå»ºç«‹"}
                            </button>
                            <button onClick={() => setMode('menu')} className="w-full py-2 text-stone-600">å–æ¶ˆ</button>
                        </div>
                    )}

                    {mode === 'join' && (
                        <div className="bg-[#eecfa1] p-6 rounded-xl shadow-2xl max-w-sm w-full border-4 border-[#8b4513] text-stone-900">
                            <h2 className="text-xl font-bold mb-4 text-center">åŠ å…¥æˆ¿é–“</h2>
                            <input 
                                type="text" 
                                placeholder="è¼¸å…¥ 6 ä½æ•¸æˆ¿é–“ ID" 
                                value={roomIdInput}
                                onChange={(e) => setRoomIdInput(e.target.value)}
                                className="w-full p-3 rounded border border-stone-400 mb-4 bg-white/80 font-mono text-center tracking-widest text-lg"
                            />
                            <button onClick={joinRoom} className="w-full py-3 bg-[#8b4513] text-white rounded font-bold hover:bg-[#6d360f] transition shadow-lg mb-2">åŠ å…¥</button>
                            <button onClick={() => setMode('menu')} className="w-full py-2 text-stone-600">å–æ¶ˆ</button>
                        </div>
                    )}
                </div>
            );
        };

        const MainMenu = ({ onSelectMode }) => (
            <div className="min-h-screen bg-stone-900 flex flex-col items-center justify-center p-4">
                <h1 className="text-4xl sm:text-6xl font-serif font-bold text-[#eecfa1] mb-2 tracking-widest text-center">ä¸­åœ‹è±¡æ£‹</h1>
                <p className="text-stone-400 mb-12 tracking-wider">CHINESE CHESS</p>
                <div className="flex flex-col gap-6 w-full max-w-md">
                    <button onClick={() => onSelectMode({ type: 'big' })} className="group relative overflow-hidden bg-[#eecfa1] p-6 rounded-xl shadow-lg hover:shadow-2xl transition-all hover:-translate-y-1"><div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div><div className="flex items-center justify-between relative z-10"><div className="text-left"><h2 className="text-2xl font-bold text-stone-900 mb-1">å¤§ç›¤è±¡æ£‹</h2><p className="text-stone-700 text-sm">å‚³çµ±ç©æ³•ï¼Œå–®æ©Ÿé›™äºº</p></div><div className="w-12 h-12 rounded-full border-4 border-red-700 text-red-700 font-bold flex items-center justify-center text-xl bg-[#eecfa1]">å¸¥</div></div></button>
                    <button onClick={() => onSelectMode({ type: 'small' })} className="group relative overflow-hidden bg-stone-700 p-6 rounded-xl shadow-lg hover:shadow-2xl transition-all hover:-translate-y-1 border border-stone-600"><div className="absolute inset-0 bg-black/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div><div className="flex items-center justify-between relative z-10"><div className="text-left"><h2 className="text-2xl font-bold text-[#eecfa1] mb-1">å°ç›¤è±¡æ£‹ (æš—æ£‹)</h2><p className="text-stone-400 text-sm">ç¿»ç‰Œé‹æ°£ï¼Œå–®æ©Ÿé›™äºº</p></div><div className="w-12 h-12 rounded-full bg-red-900 border-4 border-red-950 flex items-center justify-center shadow-inner"><span className="text-xs text-red-200/50">?</span></div></div></button>
                    <button onClick={() => onSelectMode({ type: 'online' })} className="group relative overflow-hidden bg-blue-900 p-6 rounded-xl shadow-lg hover:shadow-2xl transition-all hover:-translate-y-1 border border-blue-700"><div className="absolute inset-0 bg-white/10 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div><div className="flex items-center justify-between relative z-10"><div className="text-left"><h2 className="text-2xl font-bold text-blue-100 mb-1">ç·šä¸Šå°æˆ°</h2><p className="text-blue-300 text-sm">å»ºç«‹æˆ¿é–“ï¼Œé ç«¯é€£ç·š</p></div><Users className="text-blue-200" size={48} /></div></button>
                </div>
                <div className="mt-12 text-stone-600 text-sm">Designed for React Web</div>
            </div>
        );

        const App = () => {
            const [view, setView] = useState('menu'); 
            const [onlineConfig, setOnlineConfig] = useState(null); 

            const handleSelectMode = (mode) => {
                if (mode.type === 'online') setView('lobby');
                else setView(mode.type);
            };

            const handleJoinGame = (config) => {
                setOnlineConfig(config);
                setView(config.gameType === 'big' ? 'big' : 'small');
            };

            return (
                <div className="font-sans">
                    {view === 'menu' && <MainMenu onSelectMode={handleSelectMode} />}
                    {view === 'lobby' && <OnlineLobby onBack={() => setView('menu')} onJoinGame={handleJoinGame} />}
                    {view === 'big' && <BigBoardGame onBack={() => { setView('menu'); setOnlineConfig(null); }} onlineMode={onlineConfig} />}
                    {view === 'small' && <SmallBoardGame onBack={() => { setView('menu'); setOnlineConfig(null); }} onlineMode={onlineConfig} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
